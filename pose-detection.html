<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–†–æ–∑–ø—ñ–∑–Ω–∞–≤–∞–Ω–Ω—è –ø–æ–∑–∏</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/posenet@2.2.2"></script>
</head>
<body>
    <header>
        <h1>ü§∏ –†–æ–∑–ø—ñ–∑–Ω–∞–≤–∞–Ω–Ω—è –ø–æ–∑–∏ —Ç—ñ–ª–∞</h1>
        <p>–í—ñ–¥—Å—Ç–µ–∂—É–π—Ç–µ 17 –∫–ª—é—á–æ–≤–∏—Ö —Ç–æ—á–æ–∫ –≤–∞—à–æ–≥–æ —Ç—ñ–ª–∞ –≤ —Ä–µ–∞–ª—å–Ω–æ–º—É —á–∞—Å—ñ</p>
    </header>

    <nav class="main-nav">
        <a href="index.html" class="nav-link">–ì–æ–ª–æ–≤–Ω–∞</a>
        <a href="object-detection.html" class="nav-link">–†–æ–∑–ø—ñ–∑–Ω–∞–≤–∞–Ω–Ω—è –æ–±'—î–∫—Ç—ñ–≤</a>
        <a href="color-recognition.html" class="nav-link">–†–æ–∑–ø—ñ–∑–Ω–∞–≤–∞–Ω–Ω—è –∫–æ–ª—å–æ—Ä—ñ–≤</a>
        <a href="pose-detection.html" class="nav-link active">–†–æ–∑–ø—ñ–∑–Ω–∞–≤–∞–Ω–Ω—è –ø–æ–∑–∏</a>
        <a href="digit-recognition.html" class="nav-link">–†–æ–∑–ø—ñ–∑–Ω–∞–≤–∞–Ω–Ω—è —Ü–∏—Ñ—Ä</a>
    </nav>

    <main class="container">
        <div class="demo-container">
            <div id="loading" class="loading">
                <div class="spinner"></div>
                <p>–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –º–æ–¥–µ–ª—ñ PoseNet...</p>
            </div>

            <div id="app" style="display: none;">
                <div class="controls">
                    <button id="startBtn" class="btn">üì∑ –£–≤—ñ–º–∫–Ω—É—Ç–∏ –∫–∞–º–µ—Ä—É</button>
                    <button id="stopBtn" class="btn" style="display: none;">‚è∏Ô∏è –ó—É–ø–∏–Ω–∏—Ç–∏</button>
                    <label style="display: flex; align-items: center; gap: 0.5rem;">
                        <input type="checkbox" id="showSkeleton" checked>
                        <span>–ü–æ–∫–∞–∑–∞—Ç–∏ —Å–∫–µ–ª–µ—Ç</span>
                    </label>
                </div>

                <div class="video-container">
                    <video id="webcam" autoplay playsinline></video>
                    <canvas id="canvas"></canvas>
                </div>

                <div class="results">
                    <h3>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–∑–∏:</h3>
                    <div id="poseInfo">
                        <p style="color: #999;">–°—Ç–∞–Ω—å—Ç–µ –ø–µ—Ä–µ–¥ –∫–∞–º–µ—Ä–æ—é, —â–æ–± –ø–æ—á–∞—Ç–∏ –≤—ñ–¥—Å—Ç–µ–∂–µ–Ω–Ω—è</p>
                    </div>
                </div>
            </div>
        </div>

        <section class="info-section">
            <h2>–Ø–∫—ñ —Ç–æ—á–∫–∏ –≤—ñ–¥—Å—Ç–µ–∂—É—é—Ç—å—Å—è?</h2>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; text-align: left; color: #666;">
                <div>
                    <strong style="color: #667eea;">–ì–æ–ª–æ–≤–∞:</strong>
                    <p>‚Ä¢ –ù—ñ—Å<br>‚Ä¢ –õ—ñ–≤–µ –æ–∫–æ<br>‚Ä¢ –ü—Ä–∞–≤–µ –æ–∫–æ<br>‚Ä¢ –õ—ñ–≤–µ –≤—É—Ö–æ<br>‚Ä¢ –ü—Ä–∞–≤–µ –≤—É—Ö–æ</p>
                </div>
                <div>
                    <strong style="color: #667eea;">–¢—É–ª—É–±:</strong>
                    <p>‚Ä¢ –õ—ñ–≤–µ –ø–ª–µ—á–µ<br>‚Ä¢ –ü—Ä–∞–≤–µ –ø–ª–µ—á–µ<br>‚Ä¢ –õ—ñ–≤–µ —Å—Ç–µ–≥–Ω–æ<br>‚Ä¢ –ü—Ä–∞–≤–µ —Å—Ç–µ–≥–Ω–æ</p>
                </div>
                <div>
                    <strong style="color: #667eea;">–†—É–∫–∏:</strong>
                    <p>‚Ä¢ –õ—ñ–≤–∏–π –ª—ñ–∫–æ—Ç—å<br>‚Ä¢ –ü—Ä–∞–≤–∏–π –ª—ñ–∫–æ—Ç—å<br>‚Ä¢ –õ—ñ–≤–µ –∑–∞–ø'—è—Å—Ç—è<br>‚Ä¢ –ü—Ä–∞–≤–µ –∑–∞–ø'—è—Å—Ç—è</p>
                </div>
                <div>
                    <strong style="color: #667eea;">–ù–æ–≥–∏:</strong>
                    <p>‚Ä¢ –õ—ñ–≤–µ –∫–æ–ª—ñ–Ω–æ<br>‚Ä¢ –ü—Ä–∞–≤–µ –∫–æ–ª—ñ–Ω–æ<br>‚Ä¢ –õ—ñ–≤–∞ —â–∏–∫–æ–ª–æ—Ç–∫–∞<br>‚Ä¢ –ü—Ä–∞–≤–∞ —â–∏–∫–æ–ª–æ—Ç–∫–∞</p>
                </div>
            </div>
        </section>
    </main>

    <footer>
        <p>–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î TensorFlow.js —Ç–∞ –º–æ–¥–µ–ª—å PoseNet</p>
    </footer>

    <script>
        let net;
        let video;
        let canvas;
        let ctx;
        let isDetecting = false;
        let showSkeleton = true;

        const keypointNames = {
            'nose': '–ù—ñ—Å',
            'leftEye': '–õ—ñ–≤–µ –æ–∫–æ',
            'rightEye': '–ü—Ä–∞–≤–µ –æ–∫–æ',
            'leftEar': '–õ—ñ–≤–µ –≤—É—Ö–æ',
            'rightEar': '–ü—Ä–∞–≤–µ –≤—É—Ö–æ',
            'leftShoulder': '–õ—ñ–≤–µ –ø–ª–µ—á–µ',
            'rightShoulder': '–ü—Ä–∞–≤–µ –ø–ª–µ—á–µ',
            'leftElbow': '–õ—ñ–≤–∏–π –ª—ñ–∫–æ—Ç—å',
            'rightElbow': '–ü—Ä–∞–≤–∏–π –ª—ñ–∫–æ—Ç—å',
            'leftWrist': '–õ—ñ–≤–µ –∑–∞–ø\'—è—Å—Ç—è',
            'rightWrist': '–ü—Ä–∞–≤–µ –∑–∞–ø\'—è—Å—Ç—è',
            'leftHip': '–õ—ñ–≤–µ —Å—Ç–µ–≥–Ω–æ',
            'rightHip': '–ü—Ä–∞–≤–µ —Å—Ç–µ–≥–Ω–æ',
            'leftKnee': '–õ—ñ–≤–µ –∫–æ–ª—ñ–Ω–æ',
            'rightKnee': '–ü—Ä–∞–≤–µ –∫–æ–ª—ñ–Ω–æ',
            'leftAnkle': '–õ—ñ–≤–∞ —â–∏–∫–æ–ª–æ—Ç–∫–∞',
            'rightAnkle': '–ü—Ä–∞–≤–∞ —â–∏–∫–æ–ª–æ—Ç–∫–∞'
        };

        const adjacentKeyPoints = [
            ['leftShoulder', 'rightShoulder'],
            ['leftShoulder', 'leftElbow'],
            ['leftElbow', 'leftWrist'],
            ['rightShoulder', 'rightElbow'],
            ['rightElbow', 'rightWrist'],
            ['leftShoulder', 'leftHip'],
            ['rightShoulder', 'rightHip'],
            ['leftHip', 'rightHip'],
            ['leftHip', 'leftKnee'],
            ['leftKnee', 'leftAnkle'],
            ['rightHip', 'rightKnee'],
            ['rightKnee', 'rightAnkle'],
            ['nose', 'leftEye'],
            ['nose', 'rightEye'],
            ['leftEye', 'leftEar'],
            ['rightEye', 'rightEar']
        ];

        async function loadModel() {
            try {
                net = await posenet.load({
                    architecture: 'MobileNetV1',
                    outputStride: 16,
                    inputResolution: { width: 640, height: 480 },
                    multiplier: 0.75
                });
                document.getElementById('loading').style.display = 'none';
                document.getElementById('app').style.display = 'block';
            } catch (error) {
                document.getElementById('loading').innerHTML = 
                    '<p style="color: red;">–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –º–æ–¥–µ–ª—ñ. –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –¥–æ —ñ–Ω—Ç–µ—Ä–Ω–µ—Ç—É.</p>';
            }
        }

        async function setupCamera() {
            video = document.getElementById('webcam');
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: 'user',
                        width: 640,
                        height: 480
                    },
                    audio: false 
                });
                video.srcObject = stream;
                
                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        resolve(video);
                    };
                });
            } catch (error) {
                alert('–ù–µ –≤–¥–∞–ª–æ—Å—è –æ—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏.');
                throw error;
            }
        }

        function drawKeypoints(keypoints) {
            keypoints.forEach(keypoint => {
                if (keypoint.score > 0.5) {
                    ctx.beginPath();
                    ctx.arc(keypoint.position.x, keypoint.position.y, 8, 0, 2 * Math.PI);
                    ctx.fillStyle = '#00ff00';
                    ctx.fill();
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });
        }

        function drawSkeleton(keypoints) {
            if (!showSkeleton) return;

            const keypointDict = {};
            keypoints.forEach(kp => {
                keypointDict[kp.part] = kp;
            });

            adjacentKeyPoints.forEach(([partA, partB]) => {
                const kpA = keypointDict[partA];
                const kpB = keypointDict[partB];

                if (kpA && kpB && kpA.score > 0.5 && kpB.score > 0.5) {
                    ctx.beginPath();
                    ctx.moveTo(kpA.position.x, kpA.position.y);
                    ctx.lineTo(kpB.position.x, kpB.position.y);
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            });
        }

        function displayPoseInfo(pose) {
            const poseInfoDiv = document.getElementById('poseInfo');
            
            if (!pose) {
                poseInfoDiv.innerHTML = '<p style="color: #999;">–õ—é–¥–∏–Ω—É –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ</p>';
                return;
            }

            const visibleKeypoints = pose.keypoints.filter(kp => kp.score > 0.5);
            const avgConfidence = (visibleKeypoints.reduce((sum, kp) => sum + kp.score, 0) / visibleKeypoints.length * 100).toFixed(1);

            let html = `
                <div class="result-item">
                    <div class="result-label">–í–ø–µ–≤–Ω–µ–Ω—ñ—Å—Ç—å —Ä–æ–∑–ø—ñ–∑–Ω–∞–≤–∞–Ω–Ω—è</div>
                    <div class="result-confidence">${avgConfidence}%</div>
                </div>
                <div class="result-item">
                    <div class="result-label">–í–∏–¥–∏–º–∏—Ö —Ç–æ—á–æ–∫</div>
                    <div class="result-confidence">${visibleKeypoints.length} / 17</div>
                </div>
            `;

            // –ü–æ–∫–∞–∑—É—î–º–æ —Ç–æ–ø-5 –Ω–∞–π–±—ñ–ª—å—à –≤–ø–µ–≤–Ω–µ–Ω–∏—Ö —Ç–æ—á–æ–∫
            const topKeypoints = [...pose.keypoints]
                .sort((a, b) => b.score - a.score)
                .slice(0, 5);

            html += '<div style="margin-top: 1rem;"><strong>–ù–∞–π–∫—Ä–∞—â–µ —Ä–æ–∑–ø—ñ–∑–Ω–∞–Ω—ñ —Ç–æ—á–∫–∏:</strong></div>';
            topKeypoints.forEach(kp => {
                html += `
                    <div class="result-item">
                        <div class="result-label">${keypointNames[kp.part] || kp.part}</div>
                        <div class="result-confidence">${(kp.score * 100).toFixed(1)}%</div>
                    </div>
                `;
            });

            poseInfoDiv.innerHTML = html;
        }

        async function detectPose() {
            if (!isDetecting) return;

            const pose = await net.estimateSinglePose(video, {
                flipHorizontal: true
            });

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (pose && pose.score > 0.3) {
                drawSkeleton(pose.keypoints);
                drawKeypoints(pose.keypoints);
                displayPoseInfo(pose);
            } else {
                displayPoseInfo(null);
            }

            requestAnimationFrame(detectPose);
        }

        document.getElementById('startBtn').addEventListener('click', async () => {
            await setupCamera();
            isDetecting = true;
            detectPose();
            document.getElementById('startBtn').style.display = 'none';
            document.getElementById('stopBtn').style.display = 'inline-block';
        });

        document.getElementById('stopBtn').addEventListener('click', () => {
            isDetecting = false;
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            document.getElementById('startBtn').style.display = 'inline-block';
            document.getElementById('stopBtn').style.display = 'none';
        });

        document.getElementById('showSkeleton').addEventListener('change', (e) => {
            showSkeleton = e.target.checked;
        });

        loadModel();
    </script>
</body>
</html>
